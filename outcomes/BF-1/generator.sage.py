

# This file was *autogenerated* from the file generator.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_8 = Integer(8); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_12 = Integer(12); _sage_const_10 = Integer(10)
load("../../../source/common/sagemath/library.sage")

class Generator(BaseGenerator):
    def data(self):
        eqvar, ineqvar = sample([var('x'),var('y'),var('z')],_sage_const_2 )


        a,b,c,d,f = sample([n*choice([-_sage_const_1 ,_sage_const_1 ]) for n in range(_sage_const_2 ,_sage_const_7 )], _sage_const_5 )

        # ensure a*b-d != 0
        d = a*b + choice([-_sage_const_1 ,_sage_const_1 ])*randrange(_sage_const_2 ,_sage_const_6 )

        LHS = b*eqvar+c
        RHS = d*eqvar+f

        solution_eq = (f-a*c)/(a*b-d)
        equation = choice ({ SR(a).mul(LHS, hold=True) == RHS, RHS == SR(a).mul(LHS, hold=True) })

    def data(self):
        eq_center = choice([-_sage_const_1 ,_sage_const_1 ])*randrange(_sage_const_1 ,_sage_const_6 )
        eq_radius = randrange(_sage_const_1 ,_sage_const_6 )
        eq_scale = randrange(_sage_const_2 ,_sage_const_6 )
        eq_offset = choice([-_sage_const_1 ,_sage_const_1 ])*randrange(_sage_const_1 , eq_scale*eq_radius)
        eq = CheckIt.shuffled_equation(eq_scale*abs(x-eq_center), - eq_scale*eq_radius) + eq_offset
        eq_set = f"{eq_center-eq_radius} , {eq_center+eq_radius}"

    irrational_dict = TBIL.small_irrationals(rational_part=(ellipsis_range(-_sage_const_8 ,Ellipsis,-_sage_const_1 ,_sage_const_1 ,Ellipsis,_sage_const_8 )),full_list=True)
    def data(self):
        

        methods=["factoring", "the square root property", "completing the square", "the quadratic formula"]
        equations =[]

        #Factoring
        r1=choice([-_sage_const_1 ,_sage_const_1 ])*choice((ellipsis_range(_sage_const_2 ,Ellipsis,_sage_const_6 )))
        #Make sure r1+r2 is odd
        if r1 % _sage_const_2  == _sage_const_0 :
            r2=choice([-_sage_const_1 ,_sage_const_1 ])*choice([_sage_const_1 ,_sage_const_3 ,_sage_const_5 ,_sage_const_7 ])
        else:
            r2 = choice([-_sage_const_1 ,_sage_const_1 ])*choice([_sage_const_2 ,_sage_const_4 ,_sage_const_6 ,_sage_const_8 ])
        equations.append( { "equation":  x**_sage_const_2 -(r1+r2)*x==-_sage_const_1 *r1*r2, "method":"factoring and the zero product property", "roots": f"{r1}\\text{{ and }}{r2}"})

        #Square root property
        a=choice((ellipsis_range(_sage_const_2 ,Ellipsis,_sage_const_5 )))
        h=choice((ellipsis_range(-_sage_const_7 ,Ellipsis,-_sage_const_1 ,_sage_const_1 ,Ellipsis,_sage_const_7 )))
        c=choice([sqrt(i) for i in (ellipsis_range(_sage_const_2 ,Ellipsis,_sage_const_12 )) if not i.is_square()])
        k=choice((ellipsis_range(-_sage_const_10 ,Ellipsis,-_sage_const_1 ,_sage_const_1 ,Ellipsis,_sage_const_10 )))
        d=k+a*c**_sage_const_2 
        equations.append( { "equation":  a*(x-h)**_sage_const_2 +k==d , "method":"the square root property", "roots": f"{latex(h+c)}\\text{{ and }}{latex(h-c)}"})

        #Completing the square

        a=choice((ellipsis_range(-_sage_const_7 ,Ellipsis,-_sage_const_1 ,_sage_const_1 ,Ellipsis,_sage_const_7 )))
        b=choice([i for i in (ellipsis_range(-_sage_const_1 *a**_sage_const_2 +_sage_const_5 ,Ellipsis,_sage_const_10 )) if not (i+a**_sage_const_2 ).is_square()])
        r1=-_sage_const_1 *a+sqrt(b+a**_sage_const_2 )
        r2=-_sage_const_1 *a-sqrt(b+a**_sage_const_2 )
        equations.append( { "equation":  x**_sage_const_2 +_sage_const_2 *a*x== b , "method":"completing the square", "roots": f"{latex(r1)}\\text{{ and }}{latex(r2)} "})

        #Quadratic Equation
        a=choice((ellipsis_range(_sage_const_1 ,Ellipsis,_sage_const_3 )))
        b=choice([_sage_const_2 *i+_sage_const_1  for i in (ellipsis_range(-_sage_const_3 ,Ellipsis,_sage_const_3 ))])*a
        c=choice([i for i in (ellipsis_range(-_sage_const_6 ,Ellipsis,_sage_const_6 )) if b**_sage_const_2 -_sage_const_4 *a*i>_sage_const_0  and not (b**_sage_const_2 -_sage_const_4 *a*i).is_square()])
        r1=(-b+sqrt(b**_sage_const_2 -_sage_const_4 *a*c))/(_sage_const_2 *a)
        r2=(-b-sqrt(b**_sage_const_2 -_sage_const_4 *a*c))/(_sage_const_2 *a)
        equations.append( { "equation": a*x**_sage_const_2 +b*x == -_sage_const_1 *c, "method":"the quadratic formula", "roots": f"{latex(r1)}\\text{{ and }}{latex(r2)}" EllipticCurve} )
        shuffle(equations)

        #Imaginary roots task
        r1=choice((ellipsis_range(-_sage_const_5 ,Ellipsis,-_sage_const_1 ,_sage_const_1 ,Ellipsis,_sage_const_5 )))+choice((ellipsis_range(_sage_const_1 ,Ellipsis,_sage_const_5 )))*I
        r2=conjugate(r1)
        imaginary_equation = expand((x-r1)*(x-r2)) == _sage_const_0 ,
        imaginary_roots = f"{latex(r1)}\\text{{ and }}{latex(r2)}"

        return {
                    "equation": equation,
                    "solution_eq": solution_eq,
                    "variable": eqvar,
                    "eq": eq,
                    "eq_set": eq_set,
                    "equations": [ {"equation": f"{latex(eq['equation'].lhs())}={latex(eq['equation'].rhs())}", 
                    "method": eq['method'], 
                    "roots": eq['roots']} for eq in equations],
                    "imaginary_equation": imaginary_equation,
                    "imaginary_roots": imaginary_roots
                }

